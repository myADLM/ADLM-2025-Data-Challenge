# net/api/routers/conversations.py

from __future__ import annotations
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status, Path
from sqlmodel import Session, select
from sqlalchemy import delete
from ..db import get_db
from ..deps import get_current_user, CurrentUser
from ..models import Conversation, ConversationMember, Message, User
from ..schemas import (
    ConversationOut, ConversationWithMessages, ConversationPatch,
    UserBrief, ShareCreate, ShareOut, ShareUpdate
)

router = APIRouter()

def _brief(u: User) -> UserBrief:
    return UserBrief(id=u.id, email=u.email, name=u.name)

def _get_conv_by_public(db: Session, public_id: str) -> Conversation | None:
    return db.exec(select(Conversation).where(Conversation.public_chat_id == public_id)).first()

def _access_role(db: Session, conv: Conversation, uid: int) -> str | None:
    if conv.user_id == uid:
        return "owner"
    m = db.exec(
        select(ConversationMember)
        .where(ConversationMember.conversation_id == conv.id, ConversationMember.user_id == uid)
    ).first()
    return (m.role if m else None)

def _shared_by(db: Session, conv_id: int, uid: int) -> User | None:
    m = db.exec(
        select(ConversationMember)
        .where(ConversationMember.conversation_id == conv_id, ConversationMember.user_id == uid)
    ).first()
    if not m:
        return None
    return db.get(User, m.invited_by)

@router.get("/conversations", response_model=List[ConversationOut])
def list_conversations(db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    # owned conversations
    owned = db.exec(select(Conversation).where(Conversation.user_id == user.id)).all()

    # shared conversations
    rows = db.exec(select(ConversationMember.conversation_id).where(ConversationMember.user_id == user.id)).all()
    # Handle multiple return types: Row/tuple/int
    shared_id_list: list[int] = []
    for r in rows or []:
        try:
            # Row or tuple
            shared_id_list.append(int(r[0]))
        except Exception:
            shared_id_list.append(int(r))
    shared_convs = db.exec(
        select(Conversation).where(Conversation.id.in_(shared_id_list))  # An empty list would generate WHERE id IN (), which SQLAlchemy treats as false
    ).all() if shared_id_list else []

    items: list[ConversationOut] = []
    for c in owned:
        items.append(ConversationOut(
            id=c.public_chat_id, title=c.title,
            last_message_at=c.last_message_at, created_at=c.created_at,
            access_role="owner", shared_by=None
        ))
    for c in shared_convs:
        inviter = _shared_by(db, c.id, user.id)
        role = _access_role(db, c, user.id) or "viewer"
        items.append(ConversationOut(
            id=c.public_chat_id, title=c.title,
            last_message_at=c.last_message_at, created_at=c.created_at,
            access_role=role,
            shared_by=_brief(inviter) if inviter else None
        ))

    items.sort(key=lambda x: (x.last_message_at, x.created_at), reverse=True)
    return items

@router.post("/conversations", response_model=ConversationOut, status_code=201)
def create_conversation(db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = Conversation(user_id=user.id, title="New Chat")  # public_chat_id is generated by the model by default
    db.add(conv); db.commit(); db.refresh(conv)
    return ConversationOut(
        id=conv.public_chat_id, title=conv.title,
        last_message_at=conv.last_message_at, created_at=conv.created_at,
        access_role="owner", shared_by=None
    )

@router.get("/conversations/{public_id}", response_model=ConversationWithMessages)
def get_conversation(public_id: str = Path(...), db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Conversation not found")
    role = _access_role(db, conv, user.id)
    if not role:
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Forbidden")

    msgs = db.exec(
        select(Message).where(Message.conversation_id == conv.id).order_by(Message.created_at.asc())
    ).all()
    inviter = None if role == "owner" else _shared_by(db, conv.id, user.id)
    return ConversationWithMessages(
        id=conv.public_chat_id, title=conv.title,
        last_message_at=conv.last_message_at, created_at=conv.created_at,
        access_role=role, shared_by=_brief(inviter) if inviter else None,
        messages=[{"role": m.role, "content": m.content, "created_at": m.created_at} for m in msgs]
    )

@router.patch("/conversations/{public_id}", response_model=ConversationOut)
def rename_conversation(public_id: str, patch: ConversationPatch, db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Conversation not found")
    role = _access_role(db, conv, user.id)
    if role not in ("owner", "editor"):
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Only owner/editor can rename")

    if patch.title and patch.title.strip():
        conv.title = patch.title.strip()
        db.add(conv); db.commit(); db.refresh(conv)

    inviter = None if role == "owner" else _shared_by(db, conv.id, user.id)
    return ConversationOut(
        id=conv.public_chat_id, title=conv.title,
        last_message_at=conv.last_message_at, created_at=conv.created_at,
        access_role=role, shared_by=_brief(inviter) if inviter else None
    )

@router.delete("/conversations/{public_id}", status_code=204)
def delete_conversation(public_id: str, db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        return
    role = _access_role(db, conv, user.id)
    if role != "owner":
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Only owner can delete")

    # Proper cascading cleanup
    db.exec(delete(ConversationMember).where(ConversationMember.conversation_id == conv.id))
    db.exec(delete(Message).where(Message.conversation_id == conv.id))
    db.delete(conv)
    db.commit()
    return

# ==== Share APIs ====

@router.get("/conversations/{public_id}/shares", response_model=List[ShareOut])
def list_shares(public_id: str, db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Conversation not found")
    role = _access_role(db, conv, user.id)
    if role not in ("owner", "editor"):
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Only owner/editor can view members")

    items = db.exec(select(ConversationMember).where(ConversationMember.conversation_id == conv.id)).all()
    out: list[ShareOut] = []
    for m in items:
        u = db.get(User, m.user_id); inv = db.get(User, m.invited_by)
        if u and inv:
            out.append(ShareOut(user=_brief(u), role=m.role, invited_by=_brief(inv), created_at=m.created_at))
    return out

@router.post("/conversations/{public_id}/shares", status_code=204)
def add_share(public_id: str, body: ShareCreate, db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Conversation not found")
    role = _access_role(db, conv, user.id)
    if role not in ("owner", "editor"):
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Only owner/editor can share")

    target = db.exec(select(User).where(User.email == body.email.lower().strip())).first()
    if not target:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "User not found")

    if target.id == conv.user_id:
        return

    existing = db.exec(
        select(ConversationMember).where(ConversationMember.conversation_id == conv.id, ConversationMember.user_id == target.id)
    ).first()
    if existing:
        existing.role = body.role
        db.add(existing)
    else:
        db.add(ConversationMember(conversation_id=conv.id, user_id=target.id, role=body.role, invited_by=user.id))
    db.commit()
    return

@router.patch("/conversations/{public_id}/shares/{target_user_id}", status_code=204)
def update_share(public_id: str, target_user_id: int, body: ShareUpdate, db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Conversation not found")
    role = _access_role(db, conv, user.id)
    if role not in ("owner", "editor"):
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Only owner/editor can update share")
    if target_user_id == conv.user_id:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Cannot change owner")

    m = db.exec(
        select(ConversationMember).where(ConversationMember.conversation_id == conv.id, ConversationMember.user_id == target_user_id)
    ).first()
    if not m:
        raise HTTPException(status.HTTP_404_NOT_FOUND, "Member not found")
    m.role = body.role
    db.add(m); db.commit()
    return

@router.delete("/conversations/{public_id}/shares/{target_user_id}", status_code=204)
def remove_share(public_id: str, target_user_id: int, db: Session = Depends(get_db), user: CurrentUser = Depends(get_current_user)):
    conv = _get_conv_by_public(db, public_id)
    if not conv:
        return
    role = _access_role(db, conv, user.id)
    if role not in ("owner", "editor"):
        raise HTTPException(status.HTTP_403_FORBIDDEN, "Only owner/editor can remove share")
    if target_user_id == conv.user_id:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Cannot remove owner")

    db.exec(
        delete(ConversationMember).where(
            ConversationMember.conversation_id == conv.id,
            ConversationMember.user_id == target_user_id
        )
    )
    db.commit()
    return
