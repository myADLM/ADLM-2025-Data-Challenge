from django.db import models
from django.conf import settings
from pathlib import Path
from django.core.files import File
from pgvector.django import VectorField


category_choices = [
    ('SOP', 'sop'),
    ('FDA/Cardiovascular', 'cardiovascular'),
    ('FDA/Clinical Chemistry', 'clinical_chemistry'),
    ('FDA/Hematology', 'hematology'),
    ('FDA/Immunology', 'immunology'),
    ('FDA/Microbiology', 'microbiology'),
    ('FDA/Molecular Genetics', 'molecular_genetics'),
    ('FDA/Obstetrics/Gynecology', 'obstetrics_gynecology'),
    ('FDA/Pathology', 'pathology'),
    ('FDA/Toxicology', 'toxicology'),
]

class Document(models.Model):
    relative_path = models.CharField(max_length=255, unique=True, db_index=True)

    marker_markdown_plain = models.TextField()
    marker_markdown_chunks_plain = models.JSONField(null=True, blank=True)

    mineru_markdown = models.TextField(null=True, blank=True, help_text="The markdown content of the document as generated by mineru.")
    mineru_json_content = models.JSONField(null=True, blank=True, help_text="The json content of the document as generated by mineru.")

    # TODO we have nougat mmd files at /mnt/ri_share/Data/31623/adlm25/markdown/nougat/
    # we should import them even if we don't use them for now.
    nougat_markdown = models.TextField(null=True, blank=True, help_text="The markdown content of the document as generated by nougat.")

    table_of_contents = models.JSONField()
    page_stats = models.JSONField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    num_pages = models.IntegerField()

    category = models.CharField(max_length=255, choices=category_choices, null=True, blank=True, help_text="The category of the document, defined by the folder from the source data.")
    fda_review_letter = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, help_text="The FDA review letter that this document is a response to, if any.")

    def __str__(self):
        return self.relative_path

    @property
    def source_pdf_path(self):
        return settings.BASE_DIR / self.relative_path.replace(".md", ".pdf")

    @property
    def source_pdf(self):
        return open(self.source_pdf_path, "rb")

    def run_marker(self):
        if self.markdown_chunks_openai is not None:
            return

        import json
        from marker.converters.pdf import PdfConverter
        from marker.models import create_model_dict
        from marker.config.parser import ConfigParser

        config = {
            "output_format": "chunks",
        }
        config_parser = ConfigParser(config)
        converter = PdfConverter(
            config=config_parser.generate_config_dict(),
            artifact_dict=create_model_dict(),
            processor_list=config_parser.get_processors(),
            renderer=config_parser.get_renderer(),
            llm_service=config_parser.get_llm_service(),
        )
        rendered = converter(str(self.source_pdf_path))
        json_data = rendered.model_dump_json()
        d = json.loads(json_data)
        self.markdown_chunks_openai = d
        self.save()



block_type_choices = [
    # These all come from marker-pdf, we'll conform the mineru types to these
    ('Caption', 'Caption'),
    ('Code', 'Code'),
    ('Equation', 'Equation'),
    ('Figure', 'Figure'),
    ('FigureGroup', 'FigureGroup'),
    ('Footnote', 'Footnote'),
    ('Form', 'Form'),
    ('Handwriting', 'Handwriting'),
    ('ListGroup', 'ListGroup'),
    ('PageFooter', 'PageFooter'),
    ('PageHeader', 'PageHeader'),
    ('Picture', 'Picture'),
    ('PictureGroup', 'PictureGroup'),
    ('SectionHeader', 'SectionHeader'),
    ('Table', 'Table'),
    ('TableGroup', 'TableGroup'),
    ('TableOfContents', 'TableOfContents'),
    ('Text', 'Text'),
    ('TextInlineMath', 'TextInlineMath'),

    # This is ours, represents a table chunk that has been converted to markdown KV style
    ('MarkdownKVTable', 'MarkdownKVTable'), # Conversion of html table to a markdown K/V format which is slightly better for an LLM
    ('VisionTable', 'VisionTable'), # Vision model output for tables, see api/management/commands/vision_model_on_tables.py
]

class Chunk(models.Model):
    document = models.ForeignKey(Document, on_delete=models.PROTECT)
    chunk_index = models.IntegerField()
    text = models.TextField()
    text_length = models.IntegerField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    page_metadata = models.JSONField()
    bbox = models.JSONField()
    is_active = models.BooleanField(default=True)
    parent_chunk = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)

    # TODO page_idx was never populated for marker-pdf, 
    # can be parsed from the page_metadata['section_hierarchy']
    page_idx = models.IntegerField(null=True, blank=True)

    image = models.ImageField(upload_to='chunks/', null=True, blank=True, help_text="Mineru provides extracted images which can be used for VLM work, but alternatively we can extract an image by bounding box for any chunk.")

    block_type = models.CharField(
        choices=block_type_choices,
        max_length=255, 
        null=True, 
        blank=True, 
        help_text="The type of block this chunk is, e.g. 'table', 'header', etc. This information is extracted from the page_metadata."
    )

    # TODO we also want to parse out the page_metadata['section_hierarchy']
    # to link the header chunks and create a breadcrumb that we can 
    # show in our context to the llm
    # NOTE: we don't really have section headers with mineru dontent...

    embedding_model = models.CharField(max_length=255, null=True, blank=True)
    embedding = VectorField(dimensions=1024, null=True, blank=True)

    def __str__(self):
        return f'<Chunk: {self.document.id}#{self.chunk_index} "{self.block_type}" {self.text[:10]}...>'

    def html_text(self):
        import markdown

        md = markdown.Markdown(
            extensions=["toc", "codehilite", "fenced_code", "tables"]
        )
        html_text = md.convert(self.text)
        return html_text
